<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>全文検索システム</title>
    <base href="/" />
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'css/app.css?v=' + new Date().getTime();
        document.head.appendChild(link);
    </script>
    <style>
        #blazor-error-ui {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 16px;
            background: #ff5252;
            color: white;
            text-align: center;
        }
        #blazor-error-ui.visible { display: block; }
    </style>
</head>
<body>
    <div id="app">
        <div style="display:flex;align-items:center;justify-content:center;height:100vh;color:#666;">
            <div style="text-align:center;">
                <div style="width:40px;height:40px;border:3px solid #e0e0e0;border-top-color:#2563eb;border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto;"></div>
                <p style="margin-top:16px;">読み込み中...</p>
            </div>
        </div>
        <style>@keyframes spin { to { transform: rotate(360deg); } }</style>
    </div>

    <div id="blazor-error-ui">
        エラーが発生しました。<a href="" style="color:white;margin-left:8px;">再読み込み</a>
    </div>

    <script src="_framework/blazor.webview.js"></script>
    <script>
        // システムのテーマ設定（prefers-color-scheme）を取得。戻り値: "dark" / "light"
        window.getPreferredColorScheme = function() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        };
        // ハイライト間ジャンプ用（行単位で移動、WinMerge風）。戻り値: "行番号|現在番号|総数" または null
        var _highlightLineIndex = -1;
        var _highlightLines = [];
        
        function _getHighlightLines() {
            // すべてのmark要素を取得し、各行（tr.code-line）にグループ化
            var marks = Array.from(document.querySelectorAll('.file-box mark'));
            var lineMap = new Map();
            marks.forEach(function(mark) {
                var row = mark.closest('.code-line') || mark.closest('tr');
                if (row && !lineMap.has(row)) {
                    lineMap.set(row, mark);
                }
            });
            return Array.from(lineMap.values());
        }
        
        window.resetHighlightNav = function() {
            _highlightLineIndex = -1;
            _highlightLines = [];
            document.querySelectorAll('.code-view tr.highlight-current').forEach(function(r) { r.classList.remove('highlight-current'); });
        };
        
        /** 初回表示用: 最初のハイライト行に即座に合わせる（アニメーションなし）。戻り値は scrollToNextHighlight と同じ形式。 */
        window.scrollToFirstHighlightInstant = function() {
            _highlightLines = _getHighlightLines();
            if (_highlightLines.length === 0) return null;
            _highlightLineIndex = 0;
            var m = _highlightLines[0];
            _applyHighlightCurrent(m);
            m.scrollIntoView({ behavior: 'auto', block: 'center' });
            return _getLineNum(m) + '|' + 1 + '|' + _highlightLines.length;
        };
        
        function _applyHighlightCurrent(mark) {
            document.querySelectorAll('.code-view tr.highlight-current').forEach(function(r) { r.classList.remove('highlight-current'); });
            var row = mark.closest('.code-line') || mark.closest('tr');
            if (row) row.classList.add('highlight-current');
        }
        
        function _getLineNum(mark) {
            var row = mark.closest('.code-line') || mark.closest('tr');
            if (!row) return 0;
            var td = row.querySelector('.line-number');
            return td ? parseInt(td.textContent, 10) || 0 : 0;
        }
        
        window.scrollToNextHighlight = function(wrap) {
            if (wrap === undefined) wrap = true;
            if (_highlightLines.length === 0) {
                _highlightLines = _getHighlightLines();
            }
            if (_highlightLines.length === 0) return null;
            if (_highlightLineIndex < 0) {
                _highlightLineIndex = 0;
            } else {
                if (!wrap && _highlightLineIndex >= _highlightLines.length - 1) return null;
                _highlightLineIndex = wrap ? (_highlightLineIndex + 1) % _highlightLines.length : Math.min(_highlightLineIndex + 1, _highlightLines.length - 1);
            }
            var m = _highlightLines[_highlightLineIndex];
            _applyHighlightCurrent(m);
            m.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return _getLineNum(m) + '|' + (_highlightLineIndex + 1) + '|' + _highlightLines.length;
        };
        
        window.scrollToPrevHighlight = function(wrap) {
            if (wrap === undefined) wrap = true;
            if (_highlightLines.length === 0) {
                _highlightLines = _getHighlightLines();
            }
            if (_highlightLines.length === 0) return null;
            if (_highlightLineIndex < 0) {
                _highlightLineIndex = _highlightLines.length - 1;
            } else {
                if (!wrap && _highlightLineIndex <= 0) return null;
                _highlightLineIndex = wrap ? (_highlightLineIndex <= 0 ? _highlightLines.length - 1 : _highlightLineIndex - 1) : Math.max(_highlightLineIndex - 1, 0);
            }
            var m = _highlightLines[_highlightLineIndex];
            _applyHighlightCurrent(m);
            m.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return _getLineNum(m) + '|' + (_highlightLineIndex + 1) + '|' + _highlightLines.length;
        };
    </script>
</body>
</html>
